using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows.Media.Media3D;
using System.Linq;
using Dynamo.Models;
using Dynamo.Nodes;
using Dynamo.Selection;
using Dynamo.Services;
using Dynamo.Utilities;
using HelixToolkit.Wpf;
using Microsoft.Practices.Prism.ViewModel;
using Newtonsoft.Json;

namespace Dynamo
{
    public delegate void VisualizationCompleteEventHandler(object sender, VisualizationEventArgs e);

    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public abstract class VisualizationManager : NotificationObject
    {
        #region private members

        private Dictionary<string, Visualization> visualizations 
            = new Dictionary<string, Visualization>();

        protected bool isUpdating = false;

        #endregion

        #region public properties

        /// <summary>
        /// A dictionary of objects to be stored for visualization.
        /// </summary>
        public Dictionary<string, Visualization> Visualizations
        {
            get { return visualizations; }
            set { visualizations = value; }
        }

        #endregion

        #region events

        /// <summary>
        /// An event triggered on the completion of visualization update.
        /// </summary>
        public event VisualizationCompleteEventHandler VisualizationUpdateComplete;
        
        #endregion

        protected VisualizationManager()
        {
            dynSettings.Controller.DynamoModel.NodeAdded += new NodeHandler(DynamoModel_NodeAdded);
            dynSettings.Controller.DynamoModel.NodeDeleted += new NodeHandler(DynamoModel_NodeDeleted);
            dynSettings.Controller.DynamoModel.ConnectorDeleted += new ConnectorHandler(DynamoModel_ConnectorDeleted);
            dynSettings.Controller.EvaluationCompleted += new EventHandler(Controller_EvaluationCompleted);
            dynSettings.Controller.DynamoViewModel.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(DynamoViewModel_PropertyChanged);
            dynSettings.Controller.RequestsRedraw += new EventHandler(Controller_RequestsRedraw);
            DynamoSelection.Instance.Selection.CollectionChanged += new System.Collections.Specialized.NotifyCollectionChangedEventHandler(Selection_CollectionChanged);
            dynSettings.Controller.DynamoModel.ModelCleared += new EventHandler(DynamoModel_ModelCleared);
        }

        void DynamoModel_ModelCleared(object sender, EventArgs e)
        {
            ClearVisualizations();
            OnVisualizationUpdateComplete(this, new VisualizationEventArgs(AggregateRenderDescriptions()));
        }

        void Selection_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            int movedItems = 0;

            //When the selection changes we move renderables from collection
            //to another. For example, if items are added, we take the visualizations
            //from the normal collections and we add them to the selected visualization.
            //When an item is removed from the selection, we put it back in the normal collection

            //process removals - any node which has a visualization, is not in the selection collection
            //and has some geometry in the selection visualization collections
            var toRemove = Visualizations.Where(x => x.Value.Description.SelectedPoints.Count > 0 ||
                                                     x.Value.Description.SelectedLines.Count > 0 ||
                                                     x.Value.Description.SelectedMeshes.Count > 0)
                                         .Where(
                                             x =>
                                             !DynamoSelection.Instance.Selection.Select(
                                                 y => (y as NodeModel).GUID.ToString()).Contains(x.Key)).Select(x=>x.Value);
            foreach (var viz in toRemove)
            {
                viz.Description.Points.AddRange(viz.Description.SelectedPoints);
                viz.Description.SelectedPoints.Clear();
                viz.Description.Lines.AddRange(viz.Description.SelectedLines);
                viz.Description.SelectedLines.Clear();
                viz.Description.Meshes.AddRange(viz.Description.SelectedMeshes);
                viz.Description.SelectedMeshes.Clear();

                movedItems++;
            }

            if (e.NewItems != null)
            {
                foreach (object item in e.NewItems)
                {
                    var node = item as NodeModel;
                    if (node == null)
                        continue;

                    if (Visualizations.ContainsKey(node.GUID.ToString()))
                    {
                        //move points, lines, and meshes to selection visuals
                        var viz = Visualizations[node.GUID.ToString()];
                        viz.Description.SelectedPoints.AddRange(viz.Description.Points);
                        viz.Description.Points.Clear();
                        viz.Description.SelectedLines.AddRange(viz.Description.Lines);
                        viz.Description.Lines.Clear();
                        viz.Description.SelectedMeshes.AddRange(viz.Description.Meshes);
                        viz.Description.Meshes.Clear();

                        movedItems++;
                    }
                } 
            }
            
            //don't trigger an update if the changes in the selection
            //had no effect on the current visualizations
            if(movedItems > 0)
                OnVisualizationUpdateComplete(this, new VisualizationEventArgs(AggregateRenderDescriptions()));
        }

        /// <summary>
        /// Handler for the controller's RequestRedraw event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void Controller_RequestsRedraw(object sender, EventArgs e)
        {
            UpdateVisualizations();
        }

        void DynamoViewModel_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "FullscreenWatchShowing")
            {
                if (dynSettings.Controller.DynamoViewModel.FullscreenWatchShowing == true)
                {
                    UpdateVisualizations();
                }
            }
        }

        /// <summary>
        /// Handler for the controller's EvaluationCompleted event.
        /// Requests and update to all active visualizations which are marked for update.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void Controller_EvaluationCompleted(object sender, EventArgs e)
        {
            //if there are no watches and background preview is
            //not showing, then don't update visualizations

            UpdateVisualizations();
        }

        /// <summary>
        /// Handler for the model's ConnectorDeleted event. Clears the visualization for
        /// the node at the 'end' of the connector.
        /// </summary>
        /// <param name="connector"></param>
        void DynamoModel_ConnectorDeleted(ConnectorModel connector)
        {
            if (connector.End.Owner is IDrawable)
            {
                if (Visualizations.ContainsKey(connector.End.Owner.GUID.ToString()))
                {
                    Visualizations.Remove(connector.End.Owner.GUID.ToString());
                }

                //tell the watches that they require re-binding.
                OnVisualizationUpdateComplete(this, new VisualizationEventArgs(AggregateRenderDescriptions()));
            }
        }

        /// <summary>
        /// Handler for the model's NodeDeleted event. Unregisters a node from visualization.
        /// Triggers an update to the visualizations after un-registering a node
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeDeleted(NodeModel node)
        {
            if (node is IDrawable)
                UnregisterFromVisualization(node);
        }

        /// <summary>
        /// Handler for the model's NodeAdded event. Registers a node for visualization.
        /// Triggers an update to the visualizations after registering a node.
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeAdded(NodeModel node)
        {
            if (node is IDrawable)
            {
                node.PropertyChanged += node_PropertyChanged;
                RegisterForVisualization(node);
            }  
        }

        /// <summary>
        /// Handler for a node model's property changed event
        /// </summary>
        /// <remarks>Used to observe changes in the nodes visualization state.
        /// </remarks>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void node_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "IsVisible")
            {
                var node = sender as NodeModel;

                if (node == null)
                    return;

                if (Visualizations.ContainsKey(node.GUID.ToString()))
                {
                    Visualization viz = Visualizations[node.GUID.ToString()];

                    if (!node.IsVisible)
                    {
                        //clear the render description
                        viz.Description.Clear();
                    }
                    if (node.IsVisible)
                    {
                        viz.RequiresUpdate = true;
                    }

                    UpdateVisualizations();
                }
            }
            else if (e.PropertyName == "IsUpstreamVisible")
            {
                //just call for an update
                //the gatherupstream method when called by
                //the watch will filter the visualiations for
                //upstream visibility.
                UpdateVisualizations();
            }
        }

        /// <summary>
        /// Register a node for visualization. Internally adds a list to the 
        /// visualizations dictionary keyed by the provided id.
        /// </summary>
        /// <param name="id">The node to register for visualization</param>
        public virtual void RegisterForVisualization(NodeModel node)
        {
            //add a key in the dictionary
            if (!Visualizations.ContainsKey(node.GUID.ToString()))
            {
                var viz = new Visualization {RequiresUpdate = false};
                Visualizations.Add(node.GUID.ToString(), viz);
            }
        }

        /// <summary>
        /// Unregister a node from visualization. Internally removes geometry from the visualizations dictionary
        /// and ensures that geometry representations are unbound from views and deleted.
        /// </summary>
        /// <param name="id">The node to unregister from visualization</param>
        public virtual void UnregisterFromVisualization(NodeModel node)
        {
            if (Visualizations.ContainsKey(node.GUID.ToString()))
            {
                Visualizations.Remove(node.GUID.ToString());
            }
        }

        /// <summary>
        /// Clear the contents of all lists containing render geometry.
        /// </summary>
        public void ClearVisualizations()
        {
            Visualizations.Values.ToList().ForEach(x=>x.Description.Clear());
        }

        /// <summary>
        /// Create visualizations including tesselated geometry representations
        /// and node preview imagery. Drawing will be overidden in child classes to draw geometry 
        /// according to the host's geometry types.
        /// </summary>
        public virtual void UpdateVisualizations()
        {
            //don't update the visualizations
            //if we're already updating.
            if (isUpdating)
                return;

            isUpdating = true;

            var worker = new BackgroundWorker();
            worker.DoWork += VisualizationUpdateThread;

            if(dynSettings.Controller.Testing)
                VisualizationUpdateThread(null,null);
            else
                worker.RunWorkerAsync();
        }

        protected virtual void VisualizationUpdateThread(object s, DoWorkEventArgs args)
        {
        }

        /// <summary>
        /// When a node enters it's evaluation, it is flagged for requiring update.
        /// We dump the geometry collection and the render descption.
        /// This ensures that, if the node errors, it will render nothing.
        /// </summary>
        /// <param name="node">The node whose visualization will be updated.</param>
        public void MarkForUpdate(NodeModel node)
        {
            //re-register the node if this call is coming from a place
            //where the node got dropped from visualization but then
            //was re-added
            if(!visualizations.ContainsKey(node.GUID.ToString()))
                RegisterForVisualization(node);

            var v = Visualizations[node.GUID.ToString()];
            
            //don't set for update if it's not visible
            //the node's evaluate will fill the geometry collection
            //but not visualizations will be calculated for the node
            if(node.IsVisible)
                v.RequiresUpdate = true;

            //clear the gometry collection and the render description
            //the geometry collection will be filled during update.
            v.Geometry.Clear();
            v.Description.Clear();
        }

        /// <summary>
        /// Aggregates all upstream geometry for the given node.
        /// </summary>
        /// <param name="node">The node whose upstream geometry you need.</param>
        /// <returns>A render description containing all upstream geometry.</returns>
        public RenderDescription RenderUpstream(NodeModel node)
        {
            var watch = new Stopwatch();
            watch.Start();

            var drawables = GetUpstreamIDrawableIds(node.Inputs);
            
            var ids = from viz in dynSettings.Controller.VisualizationManager.Visualizations
                      where drawables.Contains(viz.Key)
                      select viz;

            var rd = new RenderDescription();

            var keyValuePairs = ids as KeyValuePair<string, Visualization>[] ?? ids.ToArray();

            var pts = keyValuePairs.SelectMany(x => x.Value.Description.Points);
            var lines = keyValuePairs.SelectMany(x => x.Value.Description.Lines);
            var meshes = keyValuePairs.SelectMany(x => x.Value.Description.Meshes);
            var xs = keyValuePairs.SelectMany(x => x.Value.Description.XAxisPoints);
            var ys = keyValuePairs.SelectMany(x => x.Value.Description.YAxisPoints);
            var zs = keyValuePairs.SelectMany(x => x.Value.Description.ZAxisPoints);
            var pts_sel = keyValuePairs.SelectMany(x => x.Value.Description.SelectedPoints);
            var lines_sel = keyValuePairs.SelectMany(x => x.Value.Description.SelectedLines);
            var mesh_sel = keyValuePairs.SelectMany(x => x.Value.Description.SelectedMeshes);

            rd.Points.AddRange(pts);
            rd.Lines.AddRange(lines);
            rd.Meshes.AddRange(meshes);
            rd.XAxisPoints.AddRange(xs);
            rd.YAxisPoints.AddRange(ys);
            rd.ZAxisPoints.AddRange(zs);
            rd.SelectedPoints.AddRange(pts_sel);
            rd.SelectedLines.AddRange(lines_sel);
            rd.SelectedMeshes.AddRange(mesh_sel);

            watch.Stop();
            Debug.WriteLine(string.Format("{0} ellapsed for aggregating geometry for watch.", watch.Elapsed));

            return rd;
        }

        /// <summary>
        /// Gathers the Ids of the upstream drawable nodes.
        /// </summary>
        /// <param name="inputs">A dictionary describing the inputs on the node.</param>
        /// <returns>A collection of strings.</returns>
        private List<string> GetUpstreamIDrawableIds(Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            var drawables = new List<string>();

            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;
                var drawable = node as IDrawable;

                if(drawable != null)
                    drawables.Add(node.GUID.ToString());

                if (node.IsUpstreamVisible)
                    drawables.AddRange(GetUpstreamIDrawableIds(node.Inputs));
                //else
                //    continue; // don't bother checking if function

                //if the node is function then get all the 
                //drawables inside that node. only do this if the
                //node's workspace is the home space to avoid infinite
                //recursion in the case of custom nodes in custom nodes
                if (node is Function && node.WorkSpace == dynSettings.Controller.DynamoModel.HomeSpace)
                {
                    var func = (Function)node;
                    IEnumerable<NodeModel> topElements = func.Definition.Workspace.GetTopMostNodes();
                    foreach (NodeModel innerNode in topElements)
                    {
                        var drawableInner = innerNode as IDrawable;

                        if (drawableInner != null)
                            drawables.Add(innerNode.GUID.ToString());

                        if (node.IsUpstreamVisible)
                            drawables.AddRange(GetUpstreamIDrawableIds(innerNode.Inputs));
                    }
                }
            }

            return drawables;
        }

        /// <summary>
        /// A utility method for merging multiple meshes into one.
        /// </summary>
        /// <param name="meshes"></param>
        /// <returns></returns>
        public static MeshGeometry3D MergeMeshes(ThreadSafeList<MeshGeometry3D> meshes)
        {
            if (meshes.Count == 0)
                return null;

            int offset = 0;

            var builder = new MeshBuilder();

            foreach (MeshGeometry3D m in meshes)
            {
                foreach (var pos in m.Positions)
                {
                    builder.Positions.Add(pos);
                }
                foreach (var index in m.TriangleIndices)
                {
                    builder.TriangleIndices.Add(index + offset);
                }
                foreach (var norm in m.Normals)
                {
                    builder.Normals.Add(norm);
                }
                foreach (var tc in m.TextureCoordinates)
                {
                    builder.TextureCoordinates.Add(tc);
                }

                offset += m.Positions.Count;
            }

            return builder.ToMesh(false);
        }

        /// <summary>
        /// Called when the update of visualizations is complete.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void OnVisualizationUpdateComplete(object sender, VisualizationEventArgs e)
        {
            if (VisualizationUpdateComplete != null)
                VisualizationUpdateComplete(sender, e);
        }

        /// <summary>
        /// Helper method to total the current visualizations.
        /// </summary>
        /// <param name="pointCount"></param>
        /// <param name="lineCount"></param>
        /// <param name="meshCount"></param>
        /// <param name="xCount"></param>
        /// <param name="yCount"></param>
        /// <param name="zCount"></param>
        public void GetVisualizationCounts(
            out int pointCount, out int lineCount, out int meshCount, out int xCount, out int yCount, out int zCount)
        {
            var points = Visualizations.SelectMany(x => x.Value.Description.Points);
            var lines = Visualizations.SelectMany(x => x.Value.Description.Lines);
            var meshes = Visualizations.SelectMany(x => x.Value.Description.Meshes);
            var xs = Visualizations.SelectMany(x => x.Value.Description.XAxisPoints);
            var ys = Visualizations.SelectMany(x => x.Value.Description.YAxisPoints);
            var zs = Visualizations.SelectMany(x => x.Value.Description.ZAxisPoints);

            pointCount = points.Count();
            lineCount = lines.Count();
            meshCount = meshes.Count();
            xCount = xs.Count();
            yCount = ys.Count();
            zCount = zs.Count();
        }
    
        public RenderDescription AggregateRenderDescriptions()
        {
            var descriptions = Visualizations.Values.Select(x => x.Description).ToList();

            var rd = new RenderDescription
                {
                    Points = descriptions.SelectMany(x => x.Points).ToThreadSafeList(),
                    Lines = descriptions.SelectMany(x => x.Lines).ToThreadSafeList(),
                    SelectedPoints = descriptions.SelectMany(x => x.SelectedPoints).ToThreadSafeList(),
                    SelectedLines = descriptions.SelectMany(x => x.SelectedLines).ToThreadSafeList(),
                    XAxisPoints = descriptions.SelectMany(x => x.XAxisPoints).ToThreadSafeList(),
                    YAxisPoints = descriptions.SelectMany(x => x.YAxisPoints).ToThreadSafeList(),
                    ZAxisPoints = descriptions.SelectMany(x => x.ZAxisPoints).ToThreadSafeList(),
                    Meshes = descriptions.SelectMany(x => x.Meshes).ToThreadSafeList(),
                    SelectedMeshes = descriptions.SelectMany(x => x.SelectedMeshes).ToThreadSafeList()
                };

            return rd;
        }

        /// <summary>
        /// Log visualization update timing and geometry data.
        /// </summary>
        /// <param name="rd">The aggregated render description for the model.</param>
        /// <param name="ellapsedTime">The ellapsed time of visualization as a string.</param>
        protected void LogVisualizationUpdateData(RenderDescription rd, string ellapsedTime)
        {
            var renderDict = new Dictionary<string, object>();
            renderDict["points"] = rd.Points.Count;
            renderDict["line_segments"] = rd.Lines.Count / 2;
            renderDict["mesh_facets"] = rd.Meshes.Any()
                                            ? rd.Meshes.Select(x => x.TriangleIndices.Count / 3).Aggregate((a, b) => a + b)
                                            : 0;
            renderDict["time"] = ellapsedTime;
            renderDict["manager_type"] = this.GetType().ToString();

            var renderData = JsonConvert.SerializeObject(renderDict);

            InstrumentationLogger.LogInfo("Perf-Latency-RenderGeometryGeneration", renderData);

            //Debug.WriteLine(renderData);
        }
    }

    public class VisualizationEventArgs : EventArgs
    {
        public RenderDescription Description { get; internal set; }
        public VisualizationEventArgs(RenderDescription description)
        {
            Description = description;
        }
    }
}
